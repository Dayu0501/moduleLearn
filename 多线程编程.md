####基础概念  
多线程模型允许同一时间有多个处理单元执行统一进程中的代码，而通过分离的栈空间和共享的数据区及堆栈空间，线程可以拥有独立状态及进行快速的数据共享。  
  
####多线程模型的实现方式  
1，posix标准库的API pthread。   
2，OpenMP编译器指令。使用的便利性上1不如2。


####关键词  
1，原子操作：多线程中“最小的不可并行化的”操作。编译器可以保证原子类型的变量在多线程之间被互斥访问。这里的原子操作指的是原子变量的读写操作，因为只有读写操作的执行顺序会导致问题，而变量的计算是在cpu寄存器中的临时变量操作的，是影响不到其他线程的。
2，互斥：原子操作通常都是通过“互斥的访问”来保证的。  
3，临界区：即需要保持原子操作的部分。  
4，内存模型：即cpu访问内存的顺序（书上说内存模型：表示的是机器指令（汇编指令）是以什么样的顺序被处理器执行），分为：  
（1）顺序一致性；
（2）内存重排；   
5，内存的可见性。

内存模型：
1，处理器平台的内存模型；
2，编译器的内存模型；（编译器会根据处理器平台做相应的优化）
3，高级语言的内存模型。


  
####互斥访问的实现方式：  
1，实现互斥通常需要平台相关特殊的指令，c++11之前是通过内嵌汇编代码实现的。  
2，实现粗粒度的互斥，可以使用posix标志的pthread库中的互斥锁（mutex）。

####原子性的实现方式  
（1）处理器提供的指令。  
（2）加锁。
 

####疑问  
1，c++中的线程的实现，是不是对unix或windows系统底层的线程库的封装？  
2，在一个进程中，分离的占空间是怎样实现的？  
3，硬件是怎么实现互斥的？  
4，c++11的atomic底层是使用的汇编实现的，不是posix提供的库，c++11的mutex是对操作系统底层的API的封装。  
5，到底编译器重排和cpu重排是一回事吗？/*因为《深入理解c++11》书上的意思就是编译器对指令的重排，cpu按照重排后的顺序执行，所以也成为了cpu重排。*/
答：明白了，上面提到的两个概念是两回事，首先编译器会针对代码做指令重排的优化，优化后生成的汇编指令，cpu也不一定是按照这个汇编指令顺序执行的，会根据自己的性能优化，作指令执行的重排，称为cpu重排。
6，超标量的流水线？
7，为什么会有弱顺序的内存模型呢？
答：概括来讲，弱顺序的内存模型可以使得处理器进一步发掘指令中的并行性，使得指令执行的性能更高。
8，高级语言的执行顺序，指的是一个原子变量的上的操作顺序，还是所有的原子变量的操作顺序？
答：是第二种，下面的5就解释了这个问题，是流水线上的指令。
9，之前想到的同步语义是，一个线程的操作等另一个线程的状态，第一个线程的状态改变了，在触发第二个线程的指令，与我想的并行计算一个变量的++操作的出错不是同一回事，原子类型的变量会解决第二个问题。系统的互斥可以解决第一个的同步，也可以解决第二个并行计算的问题。原子类型的变量的并行++计算，是通过每次都是写内存，变量写的可见性作用实现的。至于在硬件层面，是怎么实现可见性功能，有待查阅研究？

c++11高级语言提供的内存模型：下面的集中参数都是在同一个线程中起作用的。
1，memory_order_relaxed：读写都可用。
2，memory_order_acquire：读操作使用。
3，memory_order_release：写操作使用。
4，memory_order_acq_rel：读写操作都可使用。
5，memory_order_consume：不建议使用了。
6，memory_order_seq_cst：读写操作都可以使用，默认使用。

常见的内存顺序组合：
（1）通常memory_order_release和memory_order_acquire配合使用，成为release_acquire内存顺序，而且这两种类型的操作，在不同线程上（cpu核心上，是写到内存的）是可见的，满足可见性。
（2）memory_order_release和memory_order_consume的配合使用会建立关于原子类型的“生产者-消费者”的同步顺序，称之为release-consume内存顺序。
（3）顺序一致性。
（4）松散顺序。
（5）memory_order_acq_rel，常用于实现CAS的基本同步原语，对应到atomic的原子操作compare_exchange_strong成员函数上，称之为aquire-release内存顺序。
 
 
c++11中的atomic类型变量的实现方式：
（1）处理器提供的指令。
（2）加锁的方式。
注：对于整型量和指针等简单类型，通常结果是无锁的原子对象；而对于另外一些类型，比如 64 位机器上大小不是 1、2、4、8（有些平台 / 编译器也支持对更大的数据进行无锁原子操作）的类型，编译器会自动为这些原子对象的操作加上锁。

c++11中的atomic首先保证了类型的原子性操作，而且也是可以指定内存的访问顺序，原子类型在操作的时候，是可传一个内存访问顺序参数的。  
可以使用atomic_flag实现自旋锁。
在c++11中，atomic类型的变量默认在线程中总是保持着顺序执行的特性，也就是顺序一致性（会在原子变量的操作上加上内存屏障，并组织编译器对其的重排优化）。如果指定了松一致性的参数特性，就可以接受非一致性的优化（这个参数应该是可以影响编译器的重排优化和cpu指令重排）。这种关系也称为"先于发生（happens-before）"。但是这样的操作会影响到程序的性能，也就是顺序一致代表着是最低效的。
对于共享内存的处理器而言，强顺序导致看到的内存中的数据被修改的顺序与机器指令中的是一致的。反之，线程间看到的内存数据被修改的顺序与机器指令中声明的不一致的话，就是弱顺序的内存模型。
  
现代处理器并不是逐条执行机器指令的，按顺序的逐条执行又称为是强顺序的。  

5.对于弱顺序模型的处理器平台，如要保证指令的执行顺序，通常需要在汇编指令中加入一条所谓的内存屏障（memory barrier）指令。该指令迫使已经进入流水线中的指令都完成后，处理器才执行起到内存屏障作用的汇编指令之后的指令。如PowerPc的sync指令，sync之前运行的指令总是先于sync之后运行的指令。
6.先于发生的关系是可以传递的，编译器针对这种关系，会在适当的地方插入内存屏障，保证指令的执行顺序。
  
额外扩展：
1，编译器是根处理器的平台相关的（arm架构arm的gcc，x86有x86的gcc），不同的处理器平台，会对应不同的汇编指令集，编译器就是针对不同的指令集，把源码编译出不同的汇编代码，跑在对应的处理器上。
2，并行编程的重点是思考如何将大量的计算问题，按需分成多个独立的、能够同时运行的部分，并找出真正需要在线程间共享的数据，实现为c++11的原子类型。


